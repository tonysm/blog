---
title: "OOP and FP"
date: 2019-07-21
published: true
description: Recently I struggled to explain the differences between OOP and FP, and in this post I'm trying to explain the reason behind the struggle. This also serves as a gentle (re)introduction to OOP
tags: [oop,functional programming]

---

Recently I got myself having a hard time to explain the difference between Object-Oriented Programming (OOP) and Functional Programming (FP). Yes, yes, you might be thinking to yourself "omg, such a basic thing, this person might be really dumb". Well, first of all, if you are really thinking that, you should consider being gentle to others, nobody knows everything and things that you consider "easy" or "basic" might not be to others for several reasons.

Second of all, you are probably right. I'm not a "10x developer". In fact, I think I am proudly a ["1x developer"](https://1x.engineer/). Anyways, what was I talking about? Ah, yes, my struggle to explain the difference between OOP and FP.

It all started when I was learning Elixir (the programming language). I was reading the docs and playing with the language, then reading the Programming Phoenix book. I remember I was having so much fun.

At one point, I got to the Elixir forum and I saw a [comment](https://elixirforum.com/t/learning-elixir-frst-impressions-plz-dont-kill-me/16424/52) from Joe Amstrong (RIP) - the creator of Erlang - on his first impressions of Elixir.

> OO programming is all about objects. Objects are things that respond to messages (or should be) - to get an object to do something you send it a message - how it does it is totally irrelevant - think of objects as black boxes, to get them to do something you send them a message, they reply by sending a message back.

> How they work is irrelevant - **whether the code in the black box is functional or imperative is irrelevant** - all that is important is that they do what they are supposed to do.

That last piece is what started the struggle. He goes on:

> Unfortunately the first big OO language based on this model (smalltalk) talked about objects and messages but messages in smalltalk were not real messages but disguised synchronous function calls - this mistake was repeated in C++ and Java and the “idea” of OO programming morphed into some weird idea that OO programming had something to do with the organisation of code into classes and methods.

This is fascinating! OOP is commonly associated with imperative languages, such as Java or C++, and because of that, they might get associated with class-based code, which causes people to think of it in terms of classes, interfaces, design patterns, SOLID. But that's not really the essence of it.

I mean, if anything, these are maybe ways to achieve it in class-based languages, I guess. Alan Kay himself - the creator of the term "OOP" - has even [mentioned](http://wiki.c2.com/?AlanKayOnMessaging) that he thinks it was a mistake to use the term "object" in the name. He says that the main focus should be on _messaging_.

> Just a gentle reminder that I took some pains at the last [OOPSLA](https://www.youtube.com/watch?v=oKg1hTOQXoY) to try to remind everyone that Smalltalk is not only NOT its syntax or the class library, it is not even about classes. I'm sorry that I long ago coined the term "objects" for this topic because it gets many people to focus on the lesser idea.

> The big idea is "messaging" -- that is what the kernal(sic) of Smalltalk/Squeak is all about (...)

After analysing what both Amstrong and Kay are saying about OOP (or "real OOP" as Alan Kay says it), and after re-reading [Kay's defintion of OOP](http://userpage.fu-berlin.de/~ram/pub/pub_jf47ht81Ht/doc_kay_oop_en):

> OOP to me means only messaging, local retention and protection and hiding of state-process, and extreme late-binding of all things. It can be done in Smalltalk and in LISP. There are possibly other systems in which this is possible, but I'm not aware of them.

This is it. This is the defintion of OOP. I was introduced to this short definition of OOP by a professor of mine in my post-graduation course on Software Engineering, but it never really clicked to me that the concepts could also be applied to other programming paradigms.

- messaging;
- local retention and protection and hiding of state-process (encapsulation); and
- extreme late-binding (polymorphism).

Nothing about classes, or types. In fact, right after the defintion of OOP, Kay also says this:

> I'm not against types, but I don't know of any type systems that aren't a complete pain, so I still like dynamic typing.

It's fascinating to see people advocating for strong typing in OOP contexts, while the person who coined the term prefers dynamic typing. Enough with this tangent, back to OOP. Let's dissect each piece of the definition.

## Messaging

Messaging is a core concept in OOP. In class-based languages, they usually come in forms on method calls, but it doesn't mean that every method call is a message, as pointed out in the [MOOM course](https://avdi.codes/courses/moom/).

In Go, for instance, you can think of messages as [_channels_](https://gobyexample.com/channels), which is a mechanism to achieve communication between goroutines. In Elixir, think of [GenServer](https://elixir-lang.org/getting-started/mix-otp/genserver.html). You start a process (something like very light-weight thread of execution) that behaves like it's own "server in the network" and receives messages from other processes and responds back to those processes with other messages (we will see an example of this later on).

So, if I got it right, messaging is more about concurrency than method calls.

## Local Retention and Protection and Hiding of State-Process

Here we are talking about encapsulation of state. Be it on instances in class-based languages, or processes in concurrent languages. The idea is that the "sender" of the message (the caller of the method or the process sending the message), has no idea of what data is hold in the internals of the message handler. It couldn't care less. All it knows is that by sending a message in this format, it can receive a response (or maybe not) back.

## Extreme late-binding

Let's see what [Wikipedia](https://en.wikipedia.org/wiki/Late_binding) has o say about late-binding:

> Late binding, dynamic binding, or dynamic linkage is a computer programming mechanism in which the method being called upon an object or the function being called with arguments is looked up by name at runtime.

In other words, late-binding is waiting until the last possible moment (at runtime) to decide how a _message_ is going to be handled. It's contrary to the idea of static binding (or early binding), usually (but not exclusive to) from statically-typed, compiled languages where a compiler binds at compilation time how the messages sent in the system will be executed and which objects/functions are going to handle it. It gives very little to figure out at runtime.

Many patterns emerged in order to achieve this in statically-typed languages, like [Inversion of Control](https://en.wikipedia.org/wiki/Inversion_of_control). Instead of statically-binding to a concrete implementation, you bind the dependency to an interface and let *something* for the runtime to figure out (via configuration, factory pattern, or what ever) which instance that implements the interface is going to handle that message.

At first I was thinking of late-binding as "duck typing", but there seems to be a [difference](https://en.wikipedia.org/wiki/Late_binding):

> In 2000, Alex Martelli coined the term "duck typing" to refer to a similar concept, but with a different emphasis. While late binding generally focuses on implementation details, duck typing focuses on the ability to ignore types and concentrate on the methods an object currently has.

Generics and Duck Typing seem to solve the same problem in [different ways](https://en.wikipedia.org/wiki/Duck_typing).

In the [Wikipedia page](https://en.wikipedia.org/wiki/Late_binding) on late binding, you can find some criticisms that to me look very similar to criticisms around "duck typing":

> Late binding may prevent forms of static analysis needed by an integrated development environment (IDE). For example, an IDE's "go to definition" feature may not function on a late-bound call, if the IDE has no way to know which class the call may refer to. A modern IDE easily solves this especially for object-oriented languages since a late-bound method always specifies an interface or base class, which is where "go to definition" leads, and "find all references" can be used to find all implementations or overrides.

> A similar problem is that possible lack of typing information may prevent the creation of dependency graphs. However, other programming methods such as abstract interfaces can result in the same problems. A modern IDE can create such dependency graphs as easily as it handles "find all references".

## Talk is cheap, show me some code

In a [recent Quora question](https://www.quora.com/What-is-Alan-Kays-definition-of-Object-Oriented), Kay mentions that the idea of objects as their own "server" was a good one (from another answer to the same question). Let's use that to demonstrate these concepts.

This is a "calculator server". It receives messages, responds to them and is able to retain state.

```elixir
defmodule CalculatorServer do
  def start_link do
    Task.start_link(fn -> loop(0) end)
  end

  defp loop(current) do
    receive do
      {:sum, amount, caller} ->
        send caller, amount + current
        loop(current + amount)
      {:sub, amount, caller} ->
        send caller, current - amount
        loop(current - amount)
      {:eq, caller} ->
        send caller, current
        loop(current)
      {:clear, caller} ->
        send caller, 0
        loop(0)
    end
  end
end

```

This is the execution of this code:

```bash
$ iex Calculator.exs
Erlang/OTP 22 [erts-10.4.4] [source] [64-bit] [smp:4:4] [ds:4:4:10] [async-threads:1] [hipe]

Interactive Elixir (1.9.1) - press Ctrl+C to exit (type h() ENTER for help)
iex(1)> {:ok, calc} = CalculatorServer.start_link
{:ok, #PID<0.110.0>}
iex(2)> send calc, {:eq, self()}
{:eq, #PID<0.108.0>}
iex(3)> flush
0
:ok
iex(4)> send calc, {:sum, 101, self()}
{:sum, 101, #PID<0.108.0>}
iex(5)> flush
101
:ok
iex(6)> send calc, {:eq, self()}
{:eq, #PID<0.108.0>}
iex(7)> flush
101
:ok
iex(8)> send calc, {:sub, 11, self()}
{:sub, 11, #PID<0.108.0>}
iex(9)> flush
90
:ok
iex(10)> send calc, {:eq, self()}
{:eq, #PID<0.108.0>}
iex(11)> flush
90
:ok
iex(12)> send calc, {:clear, self()}
{:clear, #PID<0.108.0>}
iex(13)> flush
0
:ok
iex(14)> send calc, {:eq, self()}
{:eq, #PID<0.108.0>}
iex(15)> flush
0
:ok
```

I think this is a good example of OOP. It has everything:

- messaging: you send messages to the calculator server process using its PID. There's no response. Instead, the server will send you back a message when it's done calculating;
- local retention and protection and hiding of state-processing: the calculator server stores the current value on the calculator;
- late-binding: from the caller perspective, it doesn't know anything about the server, it only knows that as long as they send the messages, the server handles it well.

Oh, and this code used to demonstrate OOP was in Elixir, a dynamic, functional language.

## Wrapping up

I couldn't explain the difference of OOP and FP because they are **not** different. In fact, they are complementary. OOP can be seen as philosophy. A way to model real world _concepts_ into computer systems and code their behavior and how they interact with each other.

You can write OOP code in Elixir, Java, PHP, or [Go](https://golang.org/doc/faq#Is_Go_an_object-oriented_language), for instance. The language or paradigm doesn't really matter much, I think.

Anyways, I hope I wasn't too confusing. Reach me out on [Twitter](https://twitter.com/tony0x01) if you want to correct me on something here (but be kind).
