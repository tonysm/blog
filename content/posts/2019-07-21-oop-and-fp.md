---
title: "OOP and FP"
date: 2019-07-21
published: true
description: Recently I struggled to explain the differences between OOP and FP, and in this post I'm trying to explain the reason behind the strugle. This also serves as a gentle (re)introduction to OOP
tags: [oop,functional programming]

---

Recently I got myself having a hard time to explain the difference between Object-Oriented Programming (OOP) and Functional Programming (FP). Yes, yes, you might be thinking to yourself "omg, such a basic thing, this person might be really dumb". Well, first of all, if you are really thinking like that, you should consider being gentle to others, nobody knows everything and things that you consider "easy" or "basic" might not be to others for several reasons.

Second of all, you are probably right. I'm not a "10x developer", in fact, I think I proudly a ["1x developer"](https://1x.engineer/). Anyways, what was I talking about? Ah, yes, my striggle to explain the difference between OOP and FP.

It all started when I was learning Elixir (the programming language). I was reading the docs and playing with the language, then reading the Programming Phoenix book. I remember I was having so much fun.

At one point, I got to the Elixir forum and I saw a [comment](https://elixirforum.com/t/learning-elixir-frst-impressions-plz-dont-kill-me/16424/52) from Joe Amstrong (RIP) - the creator of Erlang - on his first impressions of Elixir.

> OO programming is all about objects. Objects are things that respond to messages (or should be) - to get an object to do something you send it a message - how it does it is totally irrelevant - think of objects as black boxes, to get them to do something you send them a message, they reply by sending a message back.

> How they work is irrelevant - **whether the code in the black box is functional or imperative is irrelevant** - all that is important is that they do what they are supposed to do.

That last piece is what started the struggle. And he goes on:

> Unfortunately the first big OO language based on this model (smalltalk) talked about objects and messages but messages in smalltalk were not real messages but disguised synchronous function calls - this mistake was repeated in C++ and Java and the “idea” of OO programming morphed into some weird idea that OO programming had something to do with the organisation of code into classes and methods.

This is fascinating! OOP is commonly associated with imperative languages, such as Java or C++, and because of that, they might get associated with class-based code, which causes people to think of it in terms of classes, interfaces, design patterns, SOLID. But that's not really the essence of it.

I mean, these are ways to achieve it in class-based languages, I guess. Alan Kay himself - the creator of the term "OOP" - has even [mentioned](http://wiki.c2.com/?AlanKayOnMessaging) that he thinks it was a mistake to have "object" in the name. He says that the main focus should be on _messaging_.

> Just a gentle reminder that I took some pains at the last [OOPSLA](https://www.youtube.com/watch?v=oKg1hTOQXoY) to try to remind everyone that Smalltalk is not only NOT its syntax or the class library, it is not even about classes. I'm sorry that I long ago coined the term "objects" for this topic because it gets many people to focus on the lesser idea.

> The big idea is "messaging" -- that is what the kernal(sic) of Smalltalk/Squeak is all about (...)

After analysing what both Amstrong and Kay are saying about OOP (or "real OOP" as Alan Kay says it), and after re-reading [Kay's defintion of OOP](http://userpage.fu-berlin.de/~ram/pub/pub_jf47ht81Ht/doc_kay_oop_en):

> OOP to me means only messaging, local retention and protection and hiding of state-process, and extreme late-binding of all things. It can be done in Smalltalk and in LISP. There are possibly other systems in which this is possible, but I'm not aware of them.

This is it. This is the defintion of OOP. I was introduced to this short definition of OOP by a professor of mine in my post-graduation course on Software Engineering, but it never really clicked to me that the concepts could also be applid to other programming paradigms.

- messaging;
- local retention and protection and hiding of state-process; and
- extreme late-binding.

Nothing about classes, or types. In fact, right before the defintion of OOP, Kay also says this:

> (I'm not against types, but I don't know of any type systems that aren't a complete pain, so I still like dynamic typing.)

I'm with him on this, but that's for another time. Back to OOP. Let's dissect what each of these points might look like in code.

## Messaging

Messaging is a core concept in OOP. In class-based languages, they usually come in forms on method calls, but it doesn't mean that every method call is a message, as pointed out in the [MOOM course](https://avdi.codes/courses/moom/).

TODO: example of messaging in Go using channels
TODO: example of messaging in Java using classes/methods

## Local Retention and Protection and Hiding of State-Process

TODO: explain encapsulation of state in objects, or processes.
TODO: example of encapsulation in Java
TODO: example in another language
TODO: mention that getters and settes in class-based languages should be avoided, because they are a violation of OOP.

## Extreme late-binding

Let's see what [Wikipedia](https://en.wikipedia.org/wiki/Late_binding) has o say about late binding:

> Late binding, dynamic binding, or dynamic linkage is a computer programming mechanism in which the method being called upon an object or the function being called with arguments is looked up by name at runtime.

In other words, late-binding is waiting until the last possible "minute" (runtime) to decide how a _message_ is going to be handled. It's contrary to the idea of static binding (or early binding), usually (but not exclusive to) from statically-typed, compiled languages where a compiler binds at compilation time how the messages sent in the system will be executed and which objects/functions are going to handle it. It gives very little to figure out at runtime.

At first I was thinking of late-binding as "duck typing", but there seems to be a [difference](https://en.wikipedia.org/wiki/Late_binding):

> In 2000, Alex Martelli coined the term "duck typing" to refer to a similar concept, but with a different emphasis. While late binding generally focuses on implementation details, duck typing focuses on the ability to ignore types and concentrate on the methods an object currently has.

This, for instance, is early-binding:

```js
class Greeter
{
  greet = () => console.log('Hi');
}

const greeter = new Greeter();

// You store the implementation of the sayHi method for later use.
const sayHi = greeter.greet;

// Some more stuff happens.

sayHi(); // outputs: "Hi"
```

Instead of sending the message "greet" to the "greeter" object when you need and letting it decide how to achieve that (or not, if it decides to - NullObject pattern), you store the implementation in a local variable and you call it yourself.

In the same [Wikipedia page](https://en.wikipedia.org/wiki/Late_binding) on late binding, you can find some criticisms that to me look very similar to criticisms around "duck typing":

> Late binding may prevent forms of static analysis needed by an integrated development environment (IDE). For example, an IDE's "go to definition" feature may not function on a late-bound call, if the IDE has no way to know which class the call may refer to. A modern IDE easily solves this especially for object-oriented languages since a late-bound method always specifies an interface or base class, which is where "go to definition" leads, and "find all references" can be used to find all implementations or overrides.

> A similar problem is that possible lack of typing information may prevent the creation of dependency graphs. However, other programming methods such as abstract interfaces can result in the same problems. A modern IDE can create such dependency graphs as easily as it handles "find all references".

In a [recent Quora question](https://www.quora.com/What-is-Alan-Kays-definition-of-Object-Oriented), Kay mentions that the idea of objects as their own "server" was a good one (from another answer to the same question). Let's use that to demonstrate what a late-binding perhaps means. This is a "calculator server", it receives messages, responds to them and is able to retain state.

```elixir
defmodule CalculatorServer do
  def start_link do
    Task.start_link(fn -> loop(0) end)
  end

  defp loop(current) do
    receive do
      {:sum, amount, caller} ->
        send caller, amount + current
        loop(current + amount)
      {:sub, amount, caller} ->
        send caller, current - amount
        loop(current - amount)
      {:eq, caller} ->
        send caller, current
        loop(current)
      {:clear, caller} ->
        send caller, 0
        loop(0)
    end
  end
end

```

This is the execution of this code:

```bash
$ iex Calculator.exs
Erlang/OTP 22 [erts-10.4.4] [source] [64-bit] [smp:4:4] [ds:4:4:10] [async-threads:1] [hipe]

Interactive Elixir (1.9.1) - press Ctrl+C to exit (type h() ENTER for help)
iex(1)> {:ok, calc} = CalculatorServer.start_link
{:ok, #PID<0.110.0>}
iex(2)> send calc, {:eq, self()}
{:eq, #PID<0.108.0>}
iex(3)> flush
0
:ok
iex(4)> send calc, {:sum, 101, self()}
{:sum, 101, #PID<0.108.0>}
iex(5)> flush
101
:ok
iex(6)> send calc, {:eq, self()}
{:eq, #PID<0.108.0>}
iex(7)> flush
101
:ok
iex(8)> send calc, {:sub, 11, self()}
{:sub, 11, #PID<0.108.0>}
iex(9)> flush
90
:ok
iex(10)> send calc, {:eq, self()}
{:eq, #PID<0.108.0>}
iex(11)> flush
90
:ok
iex(12)> send calc, {:clear, self()}
{:clear, #PID<0.108.0>}
iex(13)> flush
0
:ok
iex(14)> send calc, {:eq, self()}
{:eq, #PID<0.108.0>}
iex(15)> flush
0
:ok
```

I think this is a good example of OOP. It has everything:

- messaging: you send messages to the calculator server process using its pid. There's no response. Instead, the server will send you back a message when it's done calculating;
- local retention and protection and hiding of state-processing: the calculator server stores the current value on the calculator;
- late-binding: from the caller perspective, it doesn't know anything about the server, it only knows that as long as they send the messages, the server handles it well.

Oh, and this code used to demonstrate OOP was in Elixir, a dynamic, functional language.

## Wrap up

I couldn't explain the difference of OOP and FP because they are **not** different. In fact, they are complementary. OOP is a philosophy. A way to model real world _concepts_ into computer systems and program their behavior and they interact.

You can write OOP code in Elixir, Java, PHP, or [Go](https://golang.org/doc/faq#Is_Go_an_object-oriented_language), for instance. The language or paradigm doesn't really matter much, I think.

TODO: Is polymorphism and decorators ways to implement late-binding in statically-typed languages?

Anyways, I hope I wasn't too confusing. Reach me out on [Twitter](https://twitter.com/tony0x01) if you want to correct me on something here (but be kind).
